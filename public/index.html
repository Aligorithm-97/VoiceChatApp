<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gribline's Paradise</title>
    <style>
      #loginScreen {
        display: none;
        flex-direction: column;
        align-items: center;
        border: 1px solid;
        padding: 100px;
        border-radius: 50px;
        color: white;
      }
      #roomScreen {
        display: none;
      }
      .hidden {
        display: none;
      }
      h1 {
        color: #007bff;
      }
      body {
        font-family: Arial, sans-serif;
        background-color: #121212;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
      }

      .container {
        background-color: #ffffff;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        text-align: center;
        width: 100%;
        max-width: 400px;
      }

      h1 {
        font-size: 24px;
        color: white;
        margin-bottom: 20px;
        text-align: center;
      }

      input {
        width: 80%;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 16px;
      }

      button {
        background-color: #007bff;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        font-size: 16px;
        cursor: pointer;
        width: 100%;
        margin: 10px 0;
      }

      button:disabled {
        background-color: #6c757d;
      }

      #login-message {
        color: red;
        margin-top: 10px;
        font-size: 14px;
      }

      #leave {
        background-color: #dc3545;
      }

      .hidden {
        display: none;
      }

      .chat-section {
        margin-top: 20px;
      }

      button:hover:not(:disabled) {
        background-color: #0056b3;
      }

      #leave:hover:not(:disabled) {
        background-color: #c82333;
      }
    </style>
  </head>
  <body>
    <div id="loginScreen">
      <h2>Gribline's Paradise</h2>
      <input type="text" id="username" placeholder="Enter your username" />
      <button id="loginBtn">Login</button>
      <p id="loginError" style="color: red" class="hidden">Invalid username</p>
    </div>

    <div id="roomScreen">
      <h1>Gribline's Paradise</h1>
      <button id="join" class="btn btn-success">Join Room</button>
      <button id="leave" class="btn btn-danger" disabled>Leave Room</button>
      <ul id="userList"></ul>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const validUsers = ["aligorithm", "gribline", "seer"];
      const socket = io();
      let localStream;
      let peerConnections = {};
      let username;

      const loginScreen = document.getElementById("loginScreen");
      const roomScreen = document.getElementById("roomScreen");
      const loginError = document.getElementById("loginError");

      loginScreen.style.display = "flex";

      document.getElementById("loginBtn").addEventListener("click", () => {
        username = document.getElementById("username").value.trim();
        if (validUsers.includes(username)) {
          loginScreen.style.display = "none";
          roomScreen.style.display = "block";
          loginError.classList.add("hidden");
        } else {
          loginError.classList.remove("hidden");
        }
      });

      async function startStreaming() {
        localStream = await navigator.mediaDevices.getUserMedia({
          audio: true,
        });
        socket.emit("join-room", username);
        localStream.getTracks().forEach((track) => {
          track.onended = () => {
            for (const key in peerConnections) {
              peerConnections[key].close();
            }
          };
        });
      }

      socket.on("user-connected", (userId) => {
        addUserToList(userId);

        const peerConnection = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
        });
        peerConnections[userId] = peerConnection;

        localStream.getTracks().forEach((track) => {
          peerConnection.addTrack(track, localStream);
        });

        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit("candidate", event.candidate, userId);
          }
        };

        peerConnection.ontrack = (event) => {
          const audio = document.createElement("audio");
          audio.srcObject = event.streams[0];
          audio.play();
        };

        peerConnection
          .createOffer()
          .then((offer) => {
            return peerConnection.setLocalDescription(offer);
          })
          .then(() => {
            socket.emit("offer", peerConnection.localDescription, userId);
          });
      });

      socket.on("offer", (offer, userId) => {
        const peerConnection = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
        });
        peerConnections[userId] = peerConnection;

        peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        localStream.getTracks().forEach((track) => {
          peerConnection.addTrack(track, localStream);
        });

        peerConnection
          .createAnswer()
          .then((answer) => {
            return peerConnection.setLocalDescription(answer);
          })
          .then(() => {
            socket.emit("answer", peerConnection.localDescription, userId);
          });

        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit("candidate", event.candidate, userId);
          }
        };

        peerConnection.ontrack = (event) => {
          const audio = document.createElement("audio");
          audio.srcObject = event.streams[0];
          audio.play();
        };
      });

      socket.on("answer", (answer, userId) => {
        peerConnections[userId].setRemoteDescription(
          new RTCSessionDescription(answer)
        );
      });

      socket.on("candidate", (candidate, userId) => {
        peerConnections[userId].addIceCandidate(new RTCIceCandidate(candidate));
      });

      socket.on("user-list", (userList) => {
        const userListElement = document.getElementById("userList");
        userListElement.innerHTML = "";
        userList.forEach((user) => {
          const li = document.createElement("li");
          li.textContent = user;
          userListElement.appendChild(li);
        });
      });

      function addUserToList(userId) {
        const userListElement = document.getElementById("userList");
        const li = document.createElement("li");
        li.textContent = userId;
        userListElement.appendChild(li);
      }

      document.getElementById("join").addEventListener("click", () => {
        startStreaming();
        document.getElementById("join").disabled = true;
        document.getElementById("leave").disabled = false;
      });

      document.getElementById("leave").addEventListener("click", () => {
        localStream.getTracks().forEach((track) => track.stop());
        for (const key in peerConnections) {
          peerConnections[key].close();
        }
        socket.disconnect();
        document.getElementById("join").disabled = false;
        document.getElementById("leave").disabled = true;
      });
    </script>
  </body>
</html>
